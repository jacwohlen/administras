-- Events table for one-time events (competitions, seminars, etc.)
CREATE TABLE IF NOT EXISTS public.events (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    title text NOT NULL,
    description text,
    date text NOT NULL, -- Date of the event (YYYY-MM-DD format)
    "timeFrom" text, -- Start time (HH:MM format)
    "timeTo" text, -- End time (HH:MM format)
    location text,
    section text,
    "maxParticipants" integer, -- Optional max participants limit
    "registrationDeadline" text, -- Optional registration deadline (YYYY-MM-DD format)
    "createdAt" timestamptz DEFAULT now(),
    "updatedAt" timestamptz DEFAULT now(),
    CONSTRAINT events_pkey PRIMARY KEY (id)
);

-- Event participants table (similar to training participants)
CREATE TABLE IF NOT EXISTS public.event_participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    "eventId" integer NOT NULL,
    "memberId" integer NOT NULL,
    "registeredAt" timestamptz DEFAULT now(),
    "attendanceStatus" text DEFAULT 'registered', -- 'registered', 'attended', 'absent', 'cancelled'
    notes text, -- Optional notes for participation
    CONSTRAINT event_participants_duplicate_pkey PRIMARY KEY ("eventId", "memberId"),
    CONSTRAINT event_participants_event_id_fkey FOREIGN KEY ("eventId") REFERENCES public.events(id) ON DELETE CASCADE,
    CONSTRAINT event_participants_member_id_fkey FOREIGN KEY ("memberId") REFERENCES public.members(id) ON DELETE CASCADE
);

-- Event logs table for attendance tracking (similar to training logs)
CREATE TABLE IF NOT EXISTS public.event_logs (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    "eventId" integer NOT NULL,
    "memberId" integer NOT NULL,
    "attendedAt" timestamptz DEFAULT now(),
    "isCoach" boolean NOT NULL DEFAULT false, -- Similar to isMainTrainer for trainings - tracks who was coaching the event
    notes text,
    CONSTRAINT event_logs_pkey PRIMARY KEY (id),
    CONSTRAINT event_logs_event_id_fkey FOREIGN KEY ("eventId") REFERENCES public.events(id) ON DELETE CASCADE,
    CONSTRAINT event_logs_member_id_fkey FOREIGN KEY ("memberId") REFERENCES public.members(id) ON DELETE CASCADE
);

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_events_date ON public.events(date);
CREATE INDEX IF NOT EXISTS idx_events_section ON public.events(section);
CREATE INDEX IF NOT EXISTS idx_event_participants_event_id ON public.event_participants("eventId");
CREATE INDEX IF NOT EXISTS idx_event_participants_member_id ON public.event_participants("memberId");
CREATE INDEX IF NOT EXISTS idx_event_logs_event_id ON public.event_logs("eventId");
CREATE INDEX IF NOT EXISTS idx_event_logs_member_id ON public.event_logs("memberId");

-- Function to get event statistics (similar to training statistics)
CREATE OR REPLACE FUNCTION get_event_participants_stats(event_id_param integer)
RETURNS TABLE (
    total_registered integer,
    total_attended integer,
    total_coaches integer,
    attendance_rate numeric
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(COUNT(DISTINCT ep."memberId"), 0)::integer as total_registered,
        COALESCE(COUNT(DISTINCT el."memberId"), 0)::integer as total_attended,
        COALESCE(COUNT(DISTINCT CASE WHEN el."isCoach" = true THEN el."memberId" END), 0)::integer as total_coaches,
        CASE 
            WHEN COUNT(DISTINCT ep."memberId") > 0 THEN 
                ROUND((COUNT(DISTINCT el."memberId")::numeric / COUNT(DISTINCT ep."memberId")::numeric) * 100, 2)
            ELSE 0
        END as attendance_rate
    FROM public.event_participants ep
    LEFT JOIN public.event_logs el ON ep."eventId" = el."eventId" AND ep."memberId" = el."memberId"
    WHERE ep."eventId" = event_id_param;
END;
$$ LANGUAGE plpgsql;

-- Function to get top event participants (similar to get_top_athletes)
CREATE OR REPLACE FUNCTION get_top_event_participants(year_param text DEFAULT NULL, section_param text DEFAULT NULL)
RETURNS TABLE (
    section text,
    "memberId" integer,
    lastname text,
    firstname text,
    count bigint,
    rank bigint
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(e.section, 'Unknown') as section,
        m.id as "memberId",
        m.lastname,
        m.firstname,
        COUNT(el.id) as count,
        RANK() OVER (PARTITION BY e.section ORDER BY COUNT(el.id) DESC) as rank
    FROM public.event_logs el
    JOIN public.events e ON el."eventId" = e.id
    JOIN public.members m ON el."memberId" = m.id
    WHERE 
        (year_param IS NULL OR EXTRACT(YEAR FROM e.date::date) = year_param::integer)
        AND (section_param IS NULL OR e.section = section_param)
    GROUP BY e.section, m.id, m.lastname, m.firstname
    ORDER BY section, count DESC, m.lastname, m.firstname;
END;
$$ LANGUAGE plpgsql;

-- Function to get upcoming events
CREATE OR REPLACE FUNCTION get_upcoming_events(limit_param integer DEFAULT 10)
RETURNS TABLE (
    id integer,
    title text,
    description text,
    date text,
    "timeFrom" text,
    "timeTo" text,
    location text,
    section text,
    "maxParticipants" integer,
    "registrationDeadline" text,
    registered_count bigint,
    attendance_count bigint
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.title,
        e.description,
        e.date,
        e."timeFrom",
        e."timeTo",
        e.location,
        e.section,
        e."maxParticipants",
        e."registrationDeadline",
        COALESCE(COUNT(DISTINCT ep."memberId"), 0) as registered_count,
        COALESCE(COUNT(DISTINCT el."memberId"), 0) as attendance_count
    FROM public.events e
    LEFT JOIN public.event_participants ep ON e.id = ep."eventId"
    LEFT JOIN public.event_logs el ON e.id = el."eventId"
    WHERE e.date::date >= CURRENT_DATE
    GROUP BY e.id, e.title, e.description, e.date, e."timeFrom", e."timeTo", e.location, e.section, e."maxParticipants", e."registrationDeadline"
    ORDER BY e.date::date ASC, e."timeFrom" ASC
    LIMIT limit_param;
END;
$$ LANGUAGE plpgsql;

-- Function to get top event coaches (similar to get_top_trainers)
CREATE OR REPLACE FUNCTION get_top_event_coaches(year_param text DEFAULT NULL, section_param text DEFAULT NULL)
RETURNS TABLE (
    section text,
    "memberId" integer,
    lastname text,
    firstname text,
    count bigint,
    rank bigint
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(e.section, 'Unknown') as section,
        m.id as "memberId",
        m.lastname,
        m.firstname,
        COUNT(el.id) as count,
        RANK() OVER (PARTITION BY e.section ORDER BY COUNT(el.id) DESC) as rank
    FROM public.event_logs el
    JOIN public.events e ON el."eventId" = e.id
    JOIN public.members m ON el."memberId" = m.id
    WHERE 
        el."isCoach" = true
        AND (year_param IS NULL OR EXTRACT(YEAR FROM e.date::date) = year_param::integer)
        AND (section_param IS NULL OR e.section = section_param)
    GROUP BY e.section, m.id, m.lastname, m.firstname
    ORDER BY section, count DESC, m.lastname, m.firstname;
END;
$$ LANGUAGE plpgsql;

-- Function to get top event coaches from a specific section (for detail pages)
CREATE OR REPLACE FUNCTION get_top_event_coaches_from_section(sect text, year text)
RETURNS TABLE (
    section text,
    "memberId" integer,
    lastname text,
    firstname text,
    count bigint,
    rank bigint
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE(e.section, 'Unknown') as section,
        m.id as "memberId",
        m.lastname,
        m.firstname,
        COUNT(el.id) as count,
        RANK() OVER (ORDER BY COUNT(el.id) DESC) as rank
    FROM public.event_logs el
    JOIN public.events e ON el."eventId" = e.id
    JOIN public.members m ON el."memberId" = m.id
    WHERE 
        el."isCoach" = true
        AND e.section = sect
        AND (year = '' OR EXTRACT(YEAR FROM e.date::date) = year::integer)
    GROUP BY e.section, m.id, m.lastname, m.firstname
    ORDER BY count DESC, m.lastname, m.firstname;
END;
$$ LANGUAGE plpgsql;

-- Enable Row Level Security on all event tables
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_logs ENABLE ROW LEVEL SECURITY;

-- Events table policies
CREATE POLICY "Allow authenticated users to read events" ON public.events
    FOR SELECT
    TO authenticated, anon
    USING (true);

CREATE POLICY "Allow authenticated users to create events" ON public.events
    FOR INSERT
    TO authenticated, anon
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to update events" ON public.events
    FOR UPDATE
    TO authenticated, anon
    USING (true)
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to delete events" ON public.events
    FOR DELETE
    TO authenticated, anon
    USING (true);

-- Event participants table policies
CREATE POLICY "Allow authenticated users to read event participants" ON public.event_participants
    FOR SELECT
    TO authenticated, anon
    USING (true);

CREATE POLICY "Allow authenticated users to create event participants" ON public.event_participants
    FOR INSERT
    TO authenticated, anon
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to update event participants" ON public.event_participants
    FOR UPDATE
    TO authenticated, anon
    USING (true)
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to delete event participants" ON public.event_participants
    FOR DELETE
    TO authenticated, anon
    USING (true);

-- Event logs table policies
CREATE POLICY "Allow authenticated users to read event logs" ON public.event_logs
    FOR SELECT
    TO authenticated, anon
    USING (true);

CREATE POLICY "Allow authenticated users to create event logs" ON public.event_logs
    FOR INSERT
    TO authenticated, anon
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to update event logs" ON public.event_logs
    FOR UPDATE
    TO authenticated, anon
    USING (true)
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to delete event logs" ON public.event_logs
    FOR DELETE
    TO authenticated, anon
    USING (true);
