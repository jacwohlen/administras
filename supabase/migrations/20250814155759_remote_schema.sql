--------------
-- Tables   --
--------------

-- members
CREATE TABLE IF NOT EXISTS public.members (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    labels jsonb,
    birthday text,
    lastname text NOT NULL,
    firstname text NOT NULL,
    mobile text,
    img text,
    "imgUploaded" timestamptz,
    CONSTRAINT members_pkey PRIMARY KEY (id)
);

-- trainings
CREATE TABLE IF NOT EXISTS public.trainings (
    id smallint GENERATED BY DEFAULT AS IDENTITY,
    weekday text,
    "dateFrom" text,
    title text,
    section text,
    "dateTo" text,
    CONSTRAINT trainings_pkey PRIMARY KEY (id)
);

-- logs
CREATE TABLE IF NOT EXISTS public.logs (
    id smallint GENERATED BY DEFAULT AS IDENTITY,
    date text NOT NULL,
    "trainingId" smallint,
    "memberId" integer,
    "isMainTrainer" boolean NOT NULL DEFAULT false,
    CONSTRAINT logs_pkey PRIMARY KEY (id),
    CONSTRAINT logs_training_id_fkey FOREIGN KEY ("trainingId") REFERENCES public.trainings(id) ON DELETE SET NULL,
    CONSTRAINT logs_member_id_fkey FOREIGN KEY ("memberId") REFERENCES public.members(id) ON DELETE SET NULL
);

-- participants
CREATE TABLE IF NOT EXISTS public.participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    "trainingId" smallint NOT NULL,
    "memberId" integer NOT NULL,
    CONSTRAINT participants_duplicate_pkey PRIMARY KEY ("trainingId", "memberId"),
    CONSTRAINT participants_training_id_fkey FOREIGN KEY ("trainingId") REFERENCES public.trainings(id) ON DELETE CASCADE,
    CONSTRAINT participants_member_id_fkey FOREIGN KEY ("memberId") REFERENCES public.members(id) ON DELETE CASCADE
);


--------------
-- Views    --
--------------

CREATE OR REPLACE VIEW public.view_logs_summary
WITH (security_invoker = on) AS
SELECT
    date,
    "trainingId",
    COUNT("memberId") AS count,
    COUNT(CASE WHEN "isMainTrainer" THEN 1 END) AS "trainerCount"
FROM public.logs
GROUP BY date, "trainingId";

CREATE OR REPLACE VIEW public.view_search_members
WITH (security_invoker = on) AS
SELECT
    id,
    concat(lastname, ' ', firstname) AS fullname,
    firstname,
    lastname
FROM public.members;

--------------------------
-- Row-Level Security   --
--------------------------
ALTER TABLE public.logs         ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.members      ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trainings    ENABLE ROW LEVEL SECURITY;

-- Read
CREATE POLICY logs_read_all         ON public.logs         FOR SELECT TO authenticated, anon USING (true);
CREATE POLICY members_read_all      ON public.members      FOR SELECT TO authenticated, anon USING (true);
CREATE POLICY participants_read_all ON public.participants FOR SELECT TO authenticated, anon USING (true);
CREATE POLICY trainings_read_all    ON public.trainings    FOR SELECT TO authenticated, anon USING (true);

-- Insert
CREATE POLICY logs_insert_all         ON public.logs         FOR INSERT TO authenticated, anon WITH CHECK (true);
CREATE POLICY members_insert_all      ON public.members      FOR INSERT TO authenticated, anon WITH CHECK (true);
CREATE POLICY participants_insert_all ON public.participants FOR INSERT TO authenticated, anon WITH CHECK (true);
CREATE POLICY trainings_insert_all    ON public.trainings    FOR INSERT TO authenticated, anon WITH CHECK (true);

-- Update
CREATE POLICY logs_update_all         ON public.logs         FOR UPDATE TO authenticated, anon USING (true) WITH CHECK (true);
CREATE POLICY members_update_all      ON public.members      FOR UPDATE TO authenticated, anon USING (true) WITH CHECK (true);
CREATE POLICY participants_update_all ON public.participants FOR UPDATE TO authenticated, anon USING (true) WITH CHECK (true);
CREATE POLICY trainings_update_all    ON public.trainings    FOR UPDATE TO authenticated, anon USING (true) WITH CHECK (true);

-- Delete
CREATE POLICY logs_delete_all         ON public.logs         FOR DELETE TO authenticated, anon USING (true);
CREATE POLICY members_delete_all      ON public.members      FOR DELETE TO authenticated, anon USING (true);
CREATE POLICY participants_delete_all ON public.participants FOR DELETE TO authenticated, anon USING (true);
CREATE POLICY trainings_delete_all    ON public.trainings    FOR DELETE TO authenticated, anon USING (true);

-----------------
-- Functions   --
-----------------

-- Enforce that emails end with @jacwohlen.ch
CREATE OR REPLACE FUNCTION public.check_user_domain()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.email NOT LIKE '%@jacwohlen.ch' THEN
    RAISE EXCEPTION 'INCORRECT_DOMAIN';
  END IF;
  RETURN NEW;
END;
$$;

-- Checklist: participants for a training (tid), joined with logs for given date d
CREATE OR REPLACE FUNCTION public.get_checklist_members(d text, tid integer)
RETURNS TABLE (
  "trainingId"    smallint,
  "memberId"      integer,
  lastname      text,
  firstname     text,
  labels        jsonb,
  img           text,
  date          text,
  "isMainTrainer" boolean
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    p."trainingId",
    p."memberId",
    m.lastname,
    m.firstname,
    m.labels,
    m.img,
    l.date,
    l."isMainTrainer"
  FROM public.participants AS p
  FULL OUTER JOIN public.logs AS l
    ON p."memberId" = l."memberId"
   AND l.date = d
   AND l."trainingId" = tid
  INNER JOIN public.members AS m
    ON m.id = p."memberId"
  WHERE p."trainingId" = tid;
END;
$$;

-- Top athletes overall for a given year (YYYY% in text date)
CREATE OR REPLACE FUNCTION public.get_top_athletes(year text)
RETURNS TABLE (
  "memberId"  integer,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members AS m ON m.id = l."memberId"
  WHERE l.date LIKE concat(year, '%')
  GROUP BY l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top athletes by section for a given year
CREATE OR REPLACE FUNCTION public.get_top_athletes_by_section(year text)
RETURNS TABLE (
  section   text,
  "memberId"  integer,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l.date LIKE concat(year, '%')
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top athletes for a specific training in a given year
CREATE OR REPLACE FUNCTION public.get_top_athletes_for_training(training integer, year text)
RETURNS TABLE (
  rank      bigint,
  section   text,
  "memberId"  smallint,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, m.lastname) AS rank,
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l.date LIKE concat(year, '%')
    AND t.id = training
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top athletes from a section in a given year
CREATE OR REPLACE FUNCTION public.get_top_athletes_from_section(sect text, year text)
RETURNS TABLE (
  rank      bigint,
  section   text,
  "memberId"  integer,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, m.lastname) AS rank,
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l.date LIKE concat(year, '%')
    AND lower(t.section) = lower(sect)
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top trainers by section for a given year ("isMainTrainer" = true)
CREATE OR REPLACE FUNCTION public.get_top_trainers_by_section(year text)
RETURNS TABLE (
  section   text,
  "memberId"  integer,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l."isMainTrainer" IS TRUE
    AND l.date LIKE concat(year, '%')
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top trainers for a specific training in a given year
CREATE OR REPLACE FUNCTION public.get_top_trainers_for_training(training integer, year text)
RETURNS TABLE (
  rank      bigint,
  section   text,
  "memberId"  smallint,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, m.lastname) AS rank,
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l.date LIKE concat(year, '%')
    AND t.id = training
    AND l."isMainTrainer" IS TRUE
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

-- Top trainers from a section in a given year
CREATE OR REPLACE FUNCTION public.get_top_trainers_from_section(sect text, year text)
RETURNS TABLE (
  rank      bigint,
  section   text,
  "memberId"  integer,
  lastname  text,
  firstname text,
  count     bigint
)
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, m.lastname) AS rank,
    t.section,
    l."memberId",
    m.lastname,
    m.firstname,
    COUNT(*)
  FROM public.logs AS l
  INNER JOIN public.members   AS m ON m.id = l."memberId"
  INNER JOIN public.trainings AS t ON t.id = l."trainingId"
  WHERE l."isMainTrainer" IS TRUE
    AND l.date LIKE concat(year, '%')
    AND lower(t.section) = lower(sect)
  GROUP BY t.section, l."memberId", m.lastname, m.firstname
  ORDER BY COUNT(*) DESC, m.lastname;
END;
$$;

